
Bootloading.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .bootloader   000002dc  00007000  00007000  00000104  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .uart         00000096  00007600  00007600  000003e0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00000070  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .stab         000006cc  00000000  00000000  00000478  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000b44  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000050  00000000  00000000  00000bc9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000054  00000000  00000000  00000c19  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000001e7  00000000  00000000  00000c6d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000107  00000000  00000000  00000e54  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000053f  00000000  00000000  00000f5b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000060  00000000  00000000  0000149c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000016d  00000000  00000000  000014fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubtypes 00000049  00000000  00000000  00001669  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000030  00000000  00000000  000016b2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .bootloader:

00007000 <main>:
#define	SIGNATURE_BYTE_1 0x1E
#define	SIGNATURE_BYTE_2 0x95
#define	SIGNATURE_BYTE_3 0x02

BOOTLOADER_SECTION int main()
{
    7000:	0f 93       	push	r16
    7002:	1f 93       	push	r17
    7004:	df 93       	push	r29
    7006:	cf 93       	push	r28
    7008:	cd b7       	in	r28, 0x3d	; 61
    700a:	de b7       	in	r29, 0x3e	; 62
    700c:	2b 97       	sbiw	r28, 0x0b	; 11
    700e:	0f b6       	in	r0, 0x3f	; 63
    7010:	f8 94       	cli
    7012:	de bf       	out	0x3e, r29	; 62
    7014:	0f be       	out	0x3f, r0	; 63
    7016:	cd bf       	out	0x3d, r28	; 61
char val;
unsigned int address;
unsigned int temp_int;

  // Disable all interrupts while boot loading
  __asm ("cli");
    7018:	f8 94       	cli
  // Clear SREG
  __asm ("eor r1,r1");
    701a:	11 24       	eor	r1, r1
  __asm	("out 0x3f,r1");
    701c:	1f be       	out	0x3f, r1	; 63
  // Spack pointer = 0x0800
  __asm ("ldi r28,0x5F");
    701e:	cf e5       	ldi	r28, 0x5F	; 95
  __asm	("ldi r29,0x08");
    7020:	d8 e0       	ldi	r29, 0x08	; 8
  __asm ("out 0x3e,r29");
    7022:	de bf       	out	0x3e, r29	; 62
  __asm ("out 0x3d,r28" );    
    7024:	cd bf       	out	0x3d, r28	; 61

  // Initialize UART: 115200 bit/s, 8 data bits, no parity
  InitUART();
    7026:	0e 94 00 3b 	call	0x7600	; 0x7600 <InitUART>
    702a:	01 c0       	rjmp	.+2      	; 0x702e <main+0x2e>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    702c:	00 00       	nop

  // Initialize UART: 115200 bit/s, 8 data bits, no parity
  InitUART();
  while (1)
  {
    val = ReadChar();
    702e:	0e 94 1f 3b 	call	0x763e	; 0x763e <ReadChar>
    7032:	8d 83       	std	Y+5, r24	; 0x05
     
    // Check autoincrement status.
    if(val=='a')
    7034:	8d 81       	ldd	r24, Y+5	; 0x05
    7036:	81 36       	cpi	r24, 0x61	; 97
    7038:	21 f4       	brne	.+8      	; 0x7042 <main+0x42>
    {
      SendChar('Y'); // Yes, we do autoincrement.
    703a:	89 e5       	ldi	r24, 0x59	; 89
    703c:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    7040:	f6 cf       	rjmp	.-20     	; 0x702e <main+0x2e>
    {
      SendChar('Y'); // Yes, we do autoincrement.
    }
    
    // Set address.
    else if(val=='A') // Set address...
    7042:	8d 81       	ldd	r24, Y+5	; 0x05
    7044:	81 34       	cpi	r24, 0x41	; 65
    7046:	91 f4       	brne	.+36     	; 0x706c <main+0x6c>
    { // NOTE: Flash addresses are given in words, not bytes.
      address=((unsigned int)ReadChar()<<8) | ReadChar(); // Read address high and low byte.
    7048:	0e 94 1f 3b 	call	0x763e	; 0x763e <ReadChar>
    704c:	88 2f       	mov	r24, r24
    704e:	90 e0       	ldi	r25, 0x00	; 0
    7050:	18 2f       	mov	r17, r24
    7052:	00 27       	eor	r16, r16
    7054:	0e 94 1f 3b 	call	0x763e	; 0x763e <ReadChar>
    7058:	88 2f       	mov	r24, r24
    705a:	90 e0       	ldi	r25, 0x00	; 0
    705c:	80 2b       	or	r24, r16
    705e:	91 2b       	or	r25, r17
    7060:	9a 83       	std	Y+2, r25	; 0x02
    7062:	89 83       	std	Y+1, r24	; 0x01
      SendChar('\r'); // Send OK back.
    7064:	8d e0       	ldi	r24, 0x0D	; 13
    7066:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    706a:	e1 cf       	rjmp	.-62     	; 0x702e <main+0x2e>
      address=((unsigned int)ReadChar()<<8) | ReadChar(); // Read address high and low byte.
      SendChar('\r'); // Send OK back.
    }
    
    // Chip erase.
    else if(val=='e')
    706c:	8d 81       	ldd	r24, Y+5	; 0x05
    706e:	85 36       	cpi	r24, 0x65	; 101
    7070:	21 f5       	brne	.+72     	; 0x70ba <main+0xba>
    {
      for(address = 0; address < APP_END; address += PAGESIZE)
    7072:	1a 82       	std	Y+2, r1	; 0x02
    7074:	19 82       	std	Y+1, r1	; 0x01
    7076:	17 c0       	rjmp	.+46     	; 0x70a6 <main+0xa6>
      { // NOTE: Here we use address as a byte-address, not word-address, for convenience.
         boot_spm_busy_wait();
    7078:	87 e5       	ldi	r24, 0x57	; 87
    707a:	90 e0       	ldi	r25, 0x00	; 0
    707c:	fc 01       	movw	r30, r24
    707e:	80 81       	ld	r24, Z
    7080:	88 2f       	mov	r24, r24
    7082:	90 e0       	ldi	r25, 0x00	; 0
    7084:	81 70       	andi	r24, 0x01	; 1
    7086:	90 70       	andi	r25, 0x00	; 0
    7088:	88 23       	and	r24, r24
    708a:	b1 f7       	brne	.-20     	; 0x7078 <main+0x78>
         boot_page_erase(address);
    708c:	23 e0       	ldi	r18, 0x03	; 3
    708e:	89 81       	ldd	r24, Y+1	; 0x01
    7090:	9a 81       	ldd	r25, Y+2	; 0x02
    7092:	fc 01       	movw	r30, r24
    7094:	20 93 57 00 	sts	0x0057, r18
    7098:	e8 95       	spm
    }
    
    // Chip erase.
    else if(val=='e')
    {
      for(address = 0; address < APP_END; address += PAGESIZE)
    709a:	89 81       	ldd	r24, Y+1	; 0x01
    709c:	9a 81       	ldd	r25, Y+2	; 0x02
    709e:	80 58       	subi	r24, 0x80	; 128
    70a0:	9f 4f       	sbci	r25, 0xFF	; 255
    70a2:	9a 83       	std	Y+2, r25	; 0x02
    70a4:	89 83       	std	Y+1, r24	; 0x01
    70a6:	89 81       	ldd	r24, Y+1	; 0x01
    70a8:	9a 81       	ldd	r25, Y+2	; 0x02
    70aa:	f8 e3       	ldi	r31, 0x38	; 56
    70ac:	80 30       	cpi	r24, 0x00	; 0
    70ae:	9f 07       	cpc	r25, r31
    70b0:	18 f3       	brcs	.-58     	; 0x7078 <main+0x78>
      { // NOTE: Here we use address as a byte-address, not word-address, for convenience.
         boot_spm_busy_wait();
         boot_page_erase(address);
       }
       SendChar('\r'); // Send OK back.
    70b2:	8d e0       	ldi	r24, 0x0D	; 13
    70b4:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    70b8:	ba cf       	rjmp	.-140    	; 0x702e <main+0x2e>
       }
       SendChar('\r'); // Send OK back.
    }

    // Read program memory.
    else if(val=='R')
    70ba:	8d 81       	ldd	r24, Y+5	; 0x05
    70bc:	82 35       	cpi	r24, 0x52	; 82
    70be:	89 f5       	brne	.+98     	; 0x7122 <main+0x122>
    {
      // Send high byte, then low byte of flash word.
      boot_spm_busy_wait();
    70c0:	87 e5       	ldi	r24, 0x57	; 87
    70c2:	90 e0       	ldi	r25, 0x00	; 0
    70c4:	fc 01       	movw	r30, r24
    70c6:	80 81       	ld	r24, Z
    70c8:	88 2f       	mov	r24, r24
    70ca:	90 e0       	ldi	r25, 0x00	; 0
    70cc:	81 70       	andi	r24, 0x01	; 1
    70ce:	90 70       	andi	r25, 0x00	; 0
    70d0:	88 23       	and	r24, r24
    70d2:	b1 f7       	brne	.-20     	; 0x70c0 <main+0xc0>
	  boot_rww_enable();
    70d4:	81 e1       	ldi	r24, 0x11	; 17
    70d6:	80 93 57 00 	sts	0x0057, r24
    70da:	e8 95       	spm
      SendChar( pgm_read_byte_near((address << 1)+1 ) );
    70dc:	89 81       	ldd	r24, Y+1	; 0x01
    70de:	9a 81       	ldd	r25, Y+2	; 0x02
    70e0:	88 0f       	add	r24, r24
    70e2:	99 1f       	adc	r25, r25
    70e4:	01 96       	adiw	r24, 0x01	; 1
    70e6:	9f 83       	std	Y+7, r25	; 0x07
    70e8:	8e 83       	std	Y+6, r24	; 0x06
    70ea:	8e 81       	ldd	r24, Y+6	; 0x06
    70ec:	9f 81       	ldd	r25, Y+7	; 0x07
    70ee:	fc 01       	movw	r30, r24
    70f0:	14 91       	lpm	r17, Z+
    70f2:	18 87       	std	Y+8, r17	; 0x08
    70f4:	88 85       	ldd	r24, Y+8	; 0x08
    70f6:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
      SendChar( pgm_read_byte_near(address << 1) );
    70fa:	89 81       	ldd	r24, Y+1	; 0x01
    70fc:	9a 81       	ldd	r25, Y+2	; 0x02
    70fe:	88 0f       	add	r24, r24
    7100:	99 1f       	adc	r25, r25
    7102:	9a 87       	std	Y+10, r25	; 0x0a
    7104:	89 87       	std	Y+9, r24	; 0x09
    7106:	89 85       	ldd	r24, Y+9	; 0x09
    7108:	9a 85       	ldd	r25, Y+10	; 0x0a
    710a:	fc 01       	movw	r30, r24
    710c:	14 91       	lpm	r17, Z+
    710e:	1b 87       	std	Y+11, r17	; 0x0b
    7110:	8b 85       	ldd	r24, Y+11	; 0x0b
    7112:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
      address++; // Auto-advance to next Flash word.
    7116:	89 81       	ldd	r24, Y+1	; 0x01
    7118:	9a 81       	ldd	r25, Y+2	; 0x02
    711a:	01 96       	adiw	r24, 0x01	; 1
    711c:	9a 83       	std	Y+2, r25	; 0x02
    711e:	89 83       	std	Y+1, r24	; 0x01
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    7120:	86 cf       	rjmp	.-244    	; 0x702e <main+0x2e>
      SendChar( pgm_read_byte_near(address << 1) );
      address++; // Auto-advance to next Flash word.
    }

    // Write program memory, low byte.
    else if(val=='c')
    7122:	8d 81       	ldd	r24, Y+5	; 0x05
    7124:	83 36       	cpi	r24, 0x63	; 99
    7126:	51 f4       	brne	.+20     	; 0x713c <main+0x13c>
    { // NOTE: Always use this command before sending high byte.
       temp_int = ReadChar(); // Get low byte for later _FILL_TEMP_WORD.
    7128:	0e 94 1f 3b 	call	0x763e	; 0x763e <ReadChar>
    712c:	88 2f       	mov	r24, r24
    712e:	90 e0       	ldi	r25, 0x00	; 0
    7130:	9c 83       	std	Y+4, r25	; 0x04
    7132:	8b 83       	std	Y+3, r24	; 0x03
       SendChar('\r'); // Send OK back.
    7134:	8d e0       	ldi	r24, 0x0D	; 13
    7136:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    713a:	79 cf       	rjmp	.-270    	; 0x702e <main+0x2e>
       temp_int = ReadChar(); // Get low byte for later _FILL_TEMP_WORD.
       SendChar('\r'); // Send OK back.
    }
 
    // Write program memory, high byte.
    else if(val=='C')
    713c:	8d 81       	ldd	r24, Y+5	; 0x05
    713e:	83 34       	cpi	r24, 0x43	; 67
    7140:	61 f5       	brne	.+88     	; 0x719a <main+0x19a>
    {
      temp_int |= ((unsigned int)ReadChar()<<8); // Get and insert high byte.
    7142:	0e 94 1f 3b 	call	0x763e	; 0x763e <ReadChar>
    7146:	88 2f       	mov	r24, r24
    7148:	90 e0       	ldi	r25, 0x00	; 0
    714a:	98 2f       	mov	r25, r24
    714c:	88 27       	eor	r24, r24
    714e:	2b 81       	ldd	r18, Y+3	; 0x03
    7150:	3c 81       	ldd	r19, Y+4	; 0x04
    7152:	82 2b       	or	r24, r18
    7154:	93 2b       	or	r25, r19
    7156:	9c 83       	std	Y+4, r25	; 0x04
    7158:	8b 83       	std	Y+3, r24	; 0x03
      boot_spm_busy_wait();
    715a:	87 e5       	ldi	r24, 0x57	; 87
    715c:	90 e0       	ldi	r25, 0x00	; 0
    715e:	fc 01       	movw	r30, r24
    7160:	80 81       	ld	r24, Z
    7162:	88 2f       	mov	r24, r24
    7164:	90 e0       	ldi	r25, 0x00	; 0
    7166:	81 70       	andi	r24, 0x01	; 1
    7168:	90 70       	andi	r25, 0x00	; 0
    716a:	88 23       	and	r24, r24
    716c:	b1 f7       	brne	.-20     	; 0x715a <main+0x15a>
	  boot_page_fill((address << 1), temp_int ); // Convert word-address to byte-address and fill.
    716e:	89 81       	ldd	r24, Y+1	; 0x01
    7170:	9a 81       	ldd	r25, Y+2	; 0x02
    7172:	88 0f       	add	r24, r24
    7174:	99 1f       	adc	r25, r25
    7176:	41 e0       	ldi	r20, 0x01	; 1
    7178:	2b 81       	ldd	r18, Y+3	; 0x03
    717a:	3c 81       	ldd	r19, Y+4	; 0x04
    717c:	fc 01       	movw	r30, r24
    717e:	09 01       	movw	r0, r18
    7180:	40 93 57 00 	sts	0x0057, r20
    7184:	e8 95       	spm
    7186:	11 24       	eor	r1, r1
      address++; // Auto-advance to next Flash word.
    7188:	89 81       	ldd	r24, Y+1	; 0x01
    718a:	9a 81       	ldd	r25, Y+2	; 0x02
    718c:	01 96       	adiw	r24, 0x01	; 1
    718e:	9a 83       	std	Y+2, r25	; 0x02
    7190:	89 83       	std	Y+1, r24	; 0x01
      SendChar('\r'); // Send OK back.
    7192:	8d e0       	ldi	r24, 0x0D	; 13
    7194:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    7198:	4a cf       	rjmp	.-364    	; 0x702e <main+0x2e>
      address++; // Auto-advance to next Flash word.
      SendChar('\r'); // Send OK back.
    }

    // Write page.
    else if(val== 'm')
    719a:	8d 81       	ldd	r24, Y+5	; 0x05
    719c:	8d 36       	cpi	r24, 0x6D	; 109
    719e:	09 f5       	brne	.+66     	; 0x71e2 <main+0x1e2>
    {
      if( address >= (APP_END>>1) ) // Protect bootloader area.
    71a0:	89 81       	ldd	r24, Y+1	; 0x01
    71a2:	9a 81       	ldd	r25, Y+2	; 0x02
    71a4:	fc e1       	ldi	r31, 0x1C	; 28
    71a6:	80 30       	cpi	r24, 0x00	; 0
    71a8:	9f 07       	cpc	r25, r31
    71aa:	20 f0       	brcs	.+8      	; 0x71b4 <main+0x1b4>
      {
        SendChar('?');
    71ac:	8f e3       	ldi	r24, 0x3F	; 63
    71ae:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    71b2:	13 c0       	rjmp	.+38     	; 0x71da <main+0x1da>
      }
      else
      {
        boot_spm_busy_wait();
    71b4:	87 e5       	ldi	r24, 0x57	; 87
    71b6:	90 e0       	ldi	r25, 0x00	; 0
    71b8:	fc 01       	movw	r30, r24
    71ba:	80 81       	ld	r24, Z
    71bc:	88 2f       	mov	r24, r24
    71be:	90 e0       	ldi	r25, 0x00	; 0
    71c0:	81 70       	andi	r24, 0x01	; 1
    71c2:	90 70       	andi	r25, 0x00	; 0
    71c4:	88 23       	and	r24, r24
    71c6:	b1 f7       	brne	.-20     	; 0x71b4 <main+0x1b4>
		boot_page_write(address << 1); // Convert word-address to byte-address and write.
    71c8:	89 81       	ldd	r24, Y+1	; 0x01
    71ca:	9a 81       	ldd	r25, Y+2	; 0x02
    71cc:	88 0f       	add	r24, r24
    71ce:	99 1f       	adc	r25, r25
    71d0:	25 e0       	ldi	r18, 0x05	; 5
    71d2:	fc 01       	movw	r30, r24
    71d4:	20 93 57 00 	sts	0x0057, r18
    71d8:	e8 95       	spm
      }
      SendChar('\r'); // Send OK back.
    71da:	8d e0       	ldi	r24, 0x0D	; 13
    71dc:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    71e0:	26 cf       	rjmp	.-436    	; 0x702e <main+0x2e>
      }
      SendChar('\r'); // Send OK back.
    }

    // Enter and leave programming mode.
    else if( (val=='P') || (val=='L') )
    71e2:	8d 81       	ldd	r24, Y+5	; 0x05
    71e4:	80 35       	cpi	r24, 0x50	; 80
    71e6:	19 f0       	breq	.+6      	; 0x71ee <main+0x1ee>
    71e8:	8d 81       	ldd	r24, Y+5	; 0x05
    71ea:	8c 34       	cpi	r24, 0x4C	; 76
    71ec:	21 f4       	brne	.+8      	; 0x71f6 <main+0x1f6>
    {
      SendChar('\r'); // Nothing special to do, just answer OK.
    71ee:	8d e0       	ldi	r24, 0x0D	; 13
    71f0:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    71f4:	72 c0       	rjmp	.+228    	; 0x72da <main+0x2da>
    }

    // Exit bootloader.
    else if(val=='E')
    71f6:	8d 81       	ldd	r24, Y+5	; 0x05
    71f8:	85 34       	cpi	r24, 0x45	; 69
    71fa:	b9 f4       	brne	.+46     	; 0x722a <main+0x22a>
    {
      boot_spm_busy_wait();
    71fc:	87 e5       	ldi	r24, 0x57	; 87
    71fe:	90 e0       	ldi	r25, 0x00	; 0
    7200:	fc 01       	movw	r30, r24
    7202:	80 81       	ld	r24, Z
    7204:	88 2f       	mov	r24, r24
    7206:	90 e0       	ldi	r25, 0x00	; 0
    7208:	81 70       	andi	r24, 0x01	; 1
    720a:	90 70       	andi	r25, 0x00	; 0
    720c:	88 23       	and	r24, r24
    720e:	b1 f7       	brne	.-20     	; 0x71fc <main+0x1fc>
	  boot_rww_enable();
    7210:	81 e1       	ldi	r24, 0x11	; 17
    7212:	80 93 57 00 	sts	0x0057, r24
    7216:	e8 95       	spm
      SendChar('\r');
    7218:	8d e0       	ldi	r24, 0x0D	; 13
    721a:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
      // Generate watchdog RESET (starting the application)
      WDTCR = 0b00001000;
    721e:	81 e4       	ldi	r24, 0x41	; 65
    7220:	90 e0       	ldi	r25, 0x00	; 0
    7222:	28 e0       	ldi	r18, 0x08	; 8
    7224:	fc 01       	movw	r30, r24
    7226:	20 83       	st	Z, r18
      while(1)
      {}  
    7228:	ff cf       	rjmp	.-2      	; 0x7228 <main+0x228>
    }

    // Get programmer type.
    else if (val=='p')
    722a:	8d 81       	ldd	r24, Y+5	; 0x05
    722c:	80 37       	cpi	r24, 0x70	; 112
    722e:	21 f4       	brne	.+8      	; 0x7238 <main+0x238>
    {
      SendChar('S'); // Answer 'SERIAL'.
    7230:	83 e5       	ldi	r24, 0x53	; 83
    7232:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    7236:	fb ce       	rjmp	.-522    	; 0x702e <main+0x2e>
    {
      SendChar('S'); // Answer 'SERIAL'.
    }

    // Return supported device codes.
    else if(val=='t')
    7238:	8d 81       	ldd	r24, Y+5	; 0x05
    723a:	84 37       	cpi	r24, 0x74	; 116
    723c:	39 f4       	brne	.+14     	; 0x724c <main+0x24c>
    {
      SendChar( PARTCODE ); // Supports only this device, of course.
    723e:	83 e7       	ldi	r24, 0x73	; 115
    7240:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
      SendChar( 0 ); // Send list terminator.
    7244:	80 e0       	ldi	r24, 0x00	; 0
    7246:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    724a:	f1 ce       	rjmp	.-542    	; 0x702e <main+0x2e>
      SendChar( PARTCODE ); // Supports only this device, of course.
      SendChar( 0 ); // Send list terminator.
    }
 
    // Set LED, clear LED and set device type.
    else if((val=='x') || (val=='y') || (val=='T'))
    724c:	8d 81       	ldd	r24, Y+5	; 0x05
    724e:	88 37       	cpi	r24, 0x78	; 120
    7250:	31 f0       	breq	.+12     	; 0x725e <main+0x25e>
    7252:	8d 81       	ldd	r24, Y+5	; 0x05
    7254:	89 37       	cpi	r24, 0x79	; 121
    7256:	19 f0       	breq	.+6      	; 0x725e <main+0x25e>
    7258:	8d 81       	ldd	r24, Y+5	; 0x05
    725a:	84 35       	cpi	r24, 0x54	; 84
    725c:	31 f4       	brne	.+12     	; 0x726a <main+0x26a>
    {
      ReadChar(); // Ignore the command and it's parameter.
    725e:	0e 94 1f 3b 	call	0x763e	; 0x763e <ReadChar>
      SendChar('\r'); // Send OK back.
    7262:	8d e0       	ldi	r24, 0x0D	; 13
    7264:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    7268:	38 c0       	rjmp	.+112    	; 0x72da <main+0x2da>
    }

    // Return programmer identifier.
    else if(val=='S')
    726a:	8d 81       	ldd	r24, Y+5	; 0x05
    726c:	83 35       	cpi	r24, 0x53	; 83
    726e:	b1 f4       	brne	.+44     	; 0x729c <main+0x29c>
    {
      SendChar('A'); // Return 'AVRBOOT'.
    7270:	81 e4       	ldi	r24, 0x41	; 65
    7272:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
      SendChar('V'); // Software identifier (programmer signature) is always 7 characters.
    7276:	86 e5       	ldi	r24, 0x56	; 86
    7278:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
      SendChar('R');
    727c:	82 e5       	ldi	r24, 0x52	; 82
    727e:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
      SendChar('B');
    7282:	82 e4       	ldi	r24, 0x42	; 66
    7284:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
      SendChar('O');
    7288:	8f e4       	ldi	r24, 0x4F	; 79
    728a:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
      SendChar('O');
    728e:	8f e4       	ldi	r24, 0x4F	; 79
    7290:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
      SendChar('T');
    7294:	84 e5       	ldi	r24, 0x54	; 84
    7296:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    729a:	c9 ce       	rjmp	.-622    	; 0x702e <main+0x2e>
      SendChar('O');
      SendChar('T');
    }

    // Return software version.
    else if(val=='V')
    729c:	8d 81       	ldd	r24, Y+5	; 0x05
    729e:	86 35       	cpi	r24, 0x56	; 86
    72a0:	39 f4       	brne	.+14     	; 0x72b0 <main+0x2b0>
    {
      SendChar('1');
    72a2:	81 e3       	ldi	r24, 0x31	; 49
    72a4:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
      SendChar('5');
    72a8:	85 e3       	ldi	r24, 0x35	; 53
    72aa:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    72ae:	bf ce       	rjmp	.-642    	; 0x702e <main+0x2e>
      SendChar('1');
      SendChar('5');
    }

    // Return signature bytes.
    else if(val=='s')
    72b0:	8d 81       	ldd	r24, Y+5	; 0x05
    72b2:	83 37       	cpi	r24, 0x73	; 115
    72b4:	51 f4       	brne	.+20     	; 0x72ca <main+0x2ca>
    {							
       SendChar( SIGNATURE_BYTE_3 );
    72b6:	82 e0       	ldi	r24, 0x02	; 2
    72b8:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
       SendChar( SIGNATURE_BYTE_2 );
    72bc:	85 e9       	ldi	r24, 0x95	; 149
    72be:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
       SendChar( SIGNATURE_BYTE_1 );
    72c2:	8e e1       	ldi	r24, 0x1E	; 30
    72c4:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    {
      SendChar('?');
    }
  }  
    72c8:	b2 ce       	rjmp	.-668    	; 0x702e <main+0x2e>
       SendChar( SIGNATURE_BYTE_2 );
       SendChar( SIGNATURE_BYTE_1 );
    }
 
    // The last command to accept is ESC (synchronization).
    else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    72ca:	8d 81       	ldd	r24, Y+5	; 0x05
    72cc:	8b 31       	cpi	r24, 0x1B	; 27
    72ce:	09 f4       	brne	.+2      	; 0x72d2 <main+0x2d2>
    72d0:	ad ce       	rjmp	.-678    	; 0x702c <main+0x2c>
    {
      SendChar('?');
    72d2:	8f e3       	ldi	r24, 0x3F	; 63
    72d4:	0e 94 31 3b 	call	0x7662	; 0x7662 <SendChar>
    }
  }  
    72d8:	aa ce       	rjmp	.-684    	; 0x702e <main+0x2e>
    72da:	a9 ce       	rjmp	.-686    	; 0x702e <main+0x2e>

Disassembly of section .uart:

00007600 <InitUART>:
// Constants
#define XTAL 3686400  

__attribute__ ((section (".uart")))
void InitUART()
{
    7600:	df 93       	push	r29
    7602:	cf 93       	push	r28
    7604:	cd b7       	in	r28, 0x3d	; 61
    7606:	de b7       	in	r29, 0x3e	; 62
  // "Normal" clock, no multiprocessor mode (= default)
  UCSRA = 0b00100000;
    7608:	8b e2       	ldi	r24, 0x2B	; 43
    760a:	90 e0       	ldi	r25, 0x00	; 0
    760c:	20 e2       	ldi	r18, 0x20	; 32
    760e:	fc 01       	movw	r30, r24
    7610:	20 83       	st	Z, r18
  // No interrupts enabled
  // Receiver enabled
  // Transmitter enabled
  UCSRB = 0b00011000;	
    7612:	8a e2       	ldi	r24, 0x2A	; 42
    7614:	90 e0       	ldi	r25, 0x00	; 0
    7616:	28 e1       	ldi	r18, 0x18	; 24
    7618:	fc 01       	movw	r30, r24
    761a:	20 83       	st	Z, r18
  // Asynchronous operation, 1 stop bit, no parity
  // 8 data bits
  UCSRC = 0b100001101;
    761c:	80 e4       	ldi	r24, 0x40	; 64
    761e:	90 e0       	ldi	r25, 0x00	; 0
    7620:	2d e0       	ldi	r18, 0x0D	; 13
    7622:	fc 01       	movw	r30, r24
    7624:	20 83       	st	Z, r18
  //Baud rate = 115200
  // Write upper part of UBRR
  UBRRH = ((XTAL/16)/115200 - 1) >> 8;
    7626:	80 e4       	ldi	r24, 0x40	; 64
    7628:	90 e0       	ldi	r25, 0x00	; 0
    762a:	fc 01       	movw	r30, r24
    762c:	10 82       	st	Z, r1
  // Write lower part of UBRR
  UBRRL = ((XTAL/16)/115200 - 1);
    762e:	89 e2       	ldi	r24, 0x29	; 41
    7630:	90 e0       	ldi	r25, 0x00	; 0
    7632:	21 e0       	ldi	r18, 0x01	; 1
    7634:	fc 01       	movw	r30, r24
    7636:	20 83       	st	Z, r18
}
    7638:	cf 91       	pop	r28
    763a:	df 91       	pop	r29
    763c:	08 95       	ret

0000763e <ReadChar>:
Awaits new character received.
Then this character is returned.
*************************************************************************/
__attribute__ ((section (".uart")))
char ReadChar()
{
    763e:	df 93       	push	r29
    7640:	cf 93       	push	r28
    7642:	cd b7       	in	r28, 0x3d	; 61
    7644:	de b7       	in	r29, 0x3e	; 62
  // Wait for new character received
  while ( (UCSRA & (1<<7)) == 0 )
    7646:	00 00       	nop
    7648:	8b e2       	ldi	r24, 0x2B	; 43
    764a:	90 e0       	ldi	r25, 0x00	; 0
    764c:	fc 01       	movw	r30, r24
    764e:	80 81       	ld	r24, Z
    7650:	88 23       	and	r24, r24
    7652:	d4 f7       	brge	.-12     	; 0x7648 <ReadChar+0xa>
  {}                        
  // Then return it
  return UDR;
    7654:	8c e2       	ldi	r24, 0x2C	; 44
    7656:	90 e0       	ldi	r25, 0x00	; 0
    7658:	fc 01       	movw	r30, r24
    765a:	80 81       	ld	r24, Z
}
    765c:	cf 91       	pop	r28
    765e:	df 91       	pop	r29
    7660:	08 95       	ret

00007662 <SendChar>:
Parameter :
	Ch : Character for sending. 
*************************************************************************/
__attribute__ ((section (".uart")))
void SendChar(char Ch)
{
    7662:	df 93       	push	r29
    7664:	cf 93       	push	r28
    7666:	0f 92       	push	r0
    7668:	cd b7       	in	r28, 0x3d	; 61
    766a:	de b7       	in	r29, 0x3e	; 62
    766c:	89 83       	std	Y+1, r24	; 0x01
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSRA & (1<<5)) == 0 )
    766e:	00 00       	nop
    7670:	8b e2       	ldi	r24, 0x2B	; 43
    7672:	90 e0       	ldi	r25, 0x00	; 0
    7674:	fc 01       	movw	r30, r24
    7676:	80 81       	ld	r24, Z
    7678:	88 2f       	mov	r24, r24
    767a:	90 e0       	ldi	r25, 0x00	; 0
    767c:	80 72       	andi	r24, 0x20	; 32
    767e:	90 70       	andi	r25, 0x00	; 0
    7680:	00 97       	sbiw	r24, 0x00	; 0
    7682:	b1 f3       	breq	.-20     	; 0x7670 <SendChar+0xe>
  {}
  // Then send the character
  UDR = Ch;
    7684:	8c e2       	ldi	r24, 0x2C	; 44
    7686:	90 e0       	ldi	r25, 0x00	; 0
    7688:	29 81       	ldd	r18, Y+1	; 0x01
    768a:	fc 01       	movw	r30, r24
    768c:	20 83       	st	Z, r18
    768e:	0f 90       	pop	r0
    7690:	cf 91       	pop	r28
    7692:	df 91       	pop	r29
    7694:	08 95       	ret

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
   8:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
   c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  10:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  14:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  18:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  1c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  20:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  24:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  28:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  2c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  30:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  34:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  38:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  3c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  40:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  44:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  48:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  4c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  50:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61
  60:	0e 94 00 38 	call	0x7000	; 0x7000 <main>
  64:	0c 94 36 00 	jmp	0x6c	; 0x6c <_exit>

00000068 <__bad_interrupt>:
  68:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000006c <_exit>:
  6c:	f8 94       	cli

0000006e <__stop_program>:
  6e:	ff cf       	rjmp	.-2      	; 0x6e <__stop_program>
